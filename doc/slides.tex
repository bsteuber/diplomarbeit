\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{ngerman}
\usepackage{bibgerm}
\usepackage{color}
\usepackage{graphicx}
\usepackage{pstricks}

\mode<presentation>  {
  \usetheme{Warsaw}
  \useoutertheme{miniframes}
  \setbeamertemplate{navigation symbols}{}
}

\newcommand{\defaultscale}{0.5}
\newcommand{\pfeil}{\item[$\Rightarrow$]}
\newcommand\ato{\rightarrow} %Morphismen

\newcommand{\sexp}{S"=Expression}
\newcommand{\sexps}{S"=Expressions}
\newcommand{\cgen}{Code"=Generierung}
\newcommand{\cpp}{C\texttt{++}}
\newcommand{\mprog}{Metaprogrammierung}

\title[\mprog{}]{Prototyp eines \sexp{}-basierten Rahmenwerks für
  sprachübergreifende \mprog{}}
\subtitle{Diplomarbeit}
\author[Benjamin Teuber]{Benjamin Teuber\\ Erstbetreuer: Daniel
  Moldt\\ Zweitbetreuer: Leonie Dreschler-Fischer}
\date{\today}
\institute{TGI-Oberseminar\\
  Universität Hamburg\\ 
  Fakultät für Mathematik, Informatik und Naturwissenschaften\\
  Department Informatik}

\begin{document}

\section{Einführung}
\subsection{Einführung}

\maketitle

\AtBeginSubsection{
\begin{frame}
\begin{center}
\structure{\Huge \insertsubsection}
\end{center}
\end{frame}
}

\begin{frame}{Themengebiet}
  \begin{itemize}
  \item Thema: \mprog{}
    \begin{itemize}
    \item Hier: \cgen{}
    \item Generative \mprog{}
    \item Statische \mprog
    \end{itemize}
  \item Starke Verbreitung
    \begin{itemize}
    \item Model-Driven Architecture
    \item Domain-Specific Languages
    \item Auch im AOSE-Projekt
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Motivation}
  \begin{itemize}
  \item Problem: Generator bauen ist aufwändig
  \item Viele Komponenten nötig
    \begin{itemize}
    \item Parser für Quellsprache
    \item Compiler in normaler Programmiersprache
    \item Templates für Zielsprache
    \end{itemize}  
  \item Wie können wir dies vereinfachen?
  \end{itemize}
\end{frame}

\begin{frame}{Zielsetzung}
  \begin{itemize}
  \item Entwurf eines eigenen Frameworks
  \item Davor:
    \begin{itemize}
    \item Vergleich bestehender Systeme
    \item Festlegen der Anforderungen
    \item Planung der Architektur
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Inhalt}
  \begin{itemize}
  \item Vorarbeit
    \begin{itemize}
    \item Vorhandene Technologien
    \item Anforderungen
    \end{itemize}
  \item MagicL
    \begin{itemize}
    \item Architektur
    \item Implementierung
    \end{itemize}
  \item Demo
  \item Schluss
  \end{itemize}
\end{frame}

\begin{frame}{Anwendungsbeispiel}
  \begin{itemize}
  \item Slide, eine DSL für Vortragsfolien
  \item Wird nach Latex kompiliert
  \end{itemize}
  \begin{figure}
    \centering
    \includegraphics[scale=0.3]{images/flow_example_simple}
    \caption{Der Slide-Compiler}
  \end{figure}
\end{frame}

\section{Vorhandene Technologien}
\subsection{Vorhandene Technologien}

\begin{frame}{Unterschiede bestehender Werkzeuge}
  \begin{itemize}
  \item Modellrepräsentation
    \begin{itemize}
    \item Zeichenketten
    \item Objekte
    \item Bäume
    \end{itemize}
  \item Art der Code-Erzeugung
    \begin{itemize}
    \item Templates
    \end{itemize}
  \item Meta-Programmiersprache
    \begin{itemize}
    \item Mächtigkeit
    \item Ausdrucksstärke
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Modellrepräsentation (1)}
  \begin{itemize}
  \item Zeichenketten
  \item Pro:
    \begin{itemize}
    \item Nötig für Serialisierung/Ausgabeformat
    \item Einfache Manipulation
    \item Universell
    \end{itemize}
  \item Contra:
    \begin{itemize}
    \item Low-Level
    \item Anfällig für Syntaxfehler
    \item Unstrukturiert
    \end{itemize}
  \end{itemize} 
\end{frame}

\begin{frame}{Modellrepräsentation (2)}
  \begin{itemize}
  \item Typisierte Objekte
  \item Pro:
    \begin{itemize}
    \item Typsicherheit
    \item Effizienz
    \end{itemize}
  \item Contra:
    \begin{itemize}
    \item Typdeklarationen nötig
    \item Manipulation komplizierter
    \end{itemize}
  \end{itemize} 
\end{frame}

\begin{frame}{Modellrepräsentation (3)}
  \begin{itemize}
  \item Ungetypte Bäume (XML, \sexps{}, JSON)
  \item Pro:
    \begin{itemize}
    \item Einfach
    \item Strukturiert
    \item Universell
    \item Sicherer als Strings
    \end{itemize}
  \item Contra:
    \begin{itemize}
    \item Nicht so sicher/effizient wie Objekte
    \end{itemize}
  \end{itemize} 
\end{frame}

\begin{frame}[fragile]{S-Expressions}
  \begin{itemize}
  \item Ein S-Expression ist entweder:
    \begin{itemize}
    \item Ein Atom, z.B. eine Zahl, ein String, eine Variable
    \item Eine Liste von S-Expressions in Notation 
    \item[] \texttt{($sexp_1$ $sexp_2$ .. $sexp_n$)}
    \end{itemize}
  \item Konvention: Knotenname an erster Stelle
  \item \textit{Strukturelle} Verarbeitung
  \item Minimale Komplexität (vgl. XML)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{S-Expressions (2)}
  \begin{block}{Beispiel: Folie in \sexps{}}
\begin{verbatim}
(slide
  (title My Slide)
  (image
    (source diagram.png)
    (caption This is a diagram))
  (list one two three))
\end{verbatim}
  \end{block}
  \begin{figure}
    \includegraphics[scale=0.2]{images/model_slide_sexp}
  \end{figure}
\end{frame}

\begin{frame}[fragile]{Templates}
  \begin{itemize}
  \item Für Dokumenterzeugung genutzt
  \item ``Schablone mit Platzhaltern''
  \item Funktion: $\mathrm{input} \ato \mathrm{doc}$
  \item Typen $\mathrm{input}$ und $\mathrm{doc}$ variieren
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{PHP}
  \begin{itemize}
  \item $\mathrm{Object}\ato\mathrm{String}$
  \item Zeichenketten problematisch da Fehleranfällig
  \item Komplette Programmiersprache
  \end{itemize}
\begin{verbatim}
<ul>
  <? foreach ($items as $item) {
       echo("<li>" . $item . "</li>");
     }
  ?>
</ul>
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{XSL Transformation}
  \begin{itemize}
  \item $\mathrm{XML} \ato \mathrm{XML}$
  \item Mächtig, aber umständliche Syntax
    \begin{itemize}
    \pfeil Praxis: Komplexe Verarbeitung in externer
      Programmiersprache
    \end{itemize}
  \item Ermöglicht direkten Aufruf sowie Matching über XPath
  \item XPath: \verb+/book[@price>35]/title+
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{XSLT (2)}

  \begin{block}{Eingabe}
\begin{verbatim}
<list>
  <item>foo</item>
  <item>bar</item>
  <item>baz</item>
</list>
\end{verbatim}
  \end{block}
  \begin{block}{Erwünschte Ausgabe}
\begin{verbatim}
<ul>
  <li>foo</li>
  <li>bar</li>
  <li>baz</li>
</ul>
\end{verbatim}
\end{block}
\end{frame}

\begin{frame}[fragile]{XSLT (3)}
\begin{verbatim}
<xsl:template match="/list">
  <ul>
    <xsl:for-each select="item">
      <li><xsl:value-of select="." /></li>
    </xsl:for-each>
  </ul>
</xsl:template>
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{Lisp-Makros}
  \begin{itemize}
  \item $\mathrm{Sexp} \ato \mathrm{Sexp}$
  \item Metasprache $=$ Zielsprache $=$ Quellsprache $=$ Lisp
  \item ``Compiler-Plugins'' in kurzer, eleganter Notation
  \item Ermöglichen inkrementelle Erweiterung des Lisp-Compilers
    \begin{itemize}
    \item ``Embedded DSLs'' - in die ursprüngliche Sprache
      integriert
    \end{itemize}
  \item Template-Syntax:
    \begin{itemize}
    \item Quasiquote mit \texttt{`}  
    \item Unquote mit \texttt{,}  
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Lisp-Makros (2)}
  \begin{block}{Eingabe}
\begin{verbatim}
(list
  (item foo)
  (item bar)
  (item baz))
\end{verbatim}
  \end{block}
  \begin{block}{Erwünschte Ausgabe}
\begin{verbatim}
(ul
  (li foo)
  (li bar)
  (li baz))
\end{verbatim}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Lisp-Makros (3)}
  \begin{block}{Makro-Umsetzung in Common Lisp}
\begin{verbatim}
(defmacro item (text)
  `(li ,text))

(defmacro list (&rest items)
  `(ul ,@items))
\end{verbatim}
  \end{block}
\end{frame}

\section{Anforderungen}
\subsection{Anforderungen}

\begin{frame}{Anforderungen}
  \begin{itemize}
  \item Lisp
    \begin{itemize}
    \item Makro-Ansatz
    \end{itemize}
  \item Modelle
    \begin{itemize}
    \item \sexps{}
    \item Objekte
    \item Strings
    \end{itemize}
  \item Generierung von Quelltext
    \begin{itemize}
    \item Nicht auf Zeichenketten-Ebene
    \item Modell für Code
    \item automatische Formatierung
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Anforderungen (2)}
  \begin{itemize}
  \item Architektur
    \begin{itemize}
    \item theoretische Fundierung
    \item visualisierbar (vgl. Petri-Netze)
    \item flexible Verarbeitungsprozesse
    \end{itemize} 
  \item Compiler-Schnittstelle
    \begin{itemize}
    \item universell - Parser, Makros
    \item automatische Auswahl über Typ
    \end{itemize}
  \item Kontrollfluss
    \begin{itemize}
    \item direkter Aufruf
    \item impliziter Aufruf durch Matching
      \begin{itemize}
      \item XPath?
      \item EBNF?
      \end{itemize}
    \end{itemize}    
  \end{itemize}
\end{frame}

\section{Architektur}
\subsection{Architektur}

\begin{frame}[fragile]{Die Sprache Haskell}
  \begin{itemize}
  \item Funktional (pur)
  \item statische Typinferenz
  \item Typklassen entsprechen Java-Interfaces
  \item Seiteneffekte dank Monaden/Arrows integrierbar
  \end{itemize}
  \begin{block}{imperatives Beispielprogramm}
\begin{verbatim}
getName :: IO String
getName = do putStrLn  "Getting Name"
             return "Harald"

main :: IO ()
main = do name <- getName
          putStrLn name
\end{verbatim}
  \end{block}
\end{frame}

\begin{frame}{Kategorientheorie}
  \begin{itemize}
  \item Sehr abstrakter Bereich der Mathematik
    \begin{itemize}    
    \item Praktisch alle mathematischen Strukturen sind Kategorien
    \item Motivation: ``Rechnen mit Funktionstypen''
    \end{itemize}
  \end{itemize}
  \begin{center}
    \includegraphics[scale=0.3]{images/cat_funs}
  \end{center}
\end{frame}

\begin{frame}{Kategorientheorie (2)}
  \begin{itemize}
  \item Morphismen zwischen Objekten: $f: \mathrm{A} \ato \mathrm{B}$
    \begin{itemize}
    \item Interpretation frei
    \item Komposition: $g \circ f$ analog Funktionen
    \item Identität: $\mathrm{id}_{A}$
    \item Produkte ($f \times g$) und Coprodukte ($f + g$)
    \end{itemize}
  \item Funktoren: Abbildungen zwischen Kategorien
  \item Weiteres: Natürliche Transformationen, Monaden etc.
  \end{itemize}
\end{frame}

\begin{frame}{Kategorien in Haskell}
  \begin{itemize}
  \item Objekte: Haskell-Datentypen 
  \item Arrows: Verarbeitungsprozesse
    \begin{itemize}
    \item pure Funktionen (Kategorie $\mathbf{Hask}$)
    \item Funktionen mit Side-Effects ($\mathbf{IOArrow}$)
    \end{itemize}
  \item eigene Arrow-Formalismen möglich
    \begin{itemize}
    \item müssen Komposition etc. implementieren
    \item Funktor von $\mathbf{Hask}$ erforderlich
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Funktoren in dieser Arbeit}
  \begin{itemize}
  \item Gleicher Arrow in verschiedenen Kategorien
    \begin{itemize}
    \item Unterschiedliche Typsignatur möglich
      \pfeil ``Verstecken'' von Teilen der Signatur
    \end{itemize}
  \item ``Domain Specific Categories''
  \item Beispiel 1: Möglichkeit zum Scheitern ($\mathbf{C}_F$)
    \begin{itemize}
    \item in $\mathbf{C}_F: \mathrm{A} \ato \mathrm{B}$
    \item in $\mathbf{C}: \mathrm{A} \ato \mathrm{B} + \mathrm{String}$
    \end{itemize}
  \item Beispiel 2: Zustände ($\mathbf{C}_S$)
    \begin{itemize}
    \item in $\mathbf{C}_S: \mathrm{A} \ato \mathrm{B}$
    \item in $\mathbf{C}: \mathrm{A} \times \mathrm{state} \ato \mathrm{B} \times \mathrm{state}$
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Überblick Architektur}
  \begin{itemize}
  \item Komplett Arrow-basiert
    \begin{itemize}
      \pfeil Generische Schnittstelle für alle Arten von Compilern
    \end{itemize}
  \item Compiler: $\mathrm{a} \ato \mathrm{b}$
  \item Parser: $\mathrm{[token]} \ato \mathrm{b}$ 
  \item Makros: $\mathrm{[Sexp]} \ato \mathrm{b}$ 
  \item Lisp-Makros: $\mathrm{[Sexp]} \ato \mathrm{[Sexp]}$
  \end{itemize}
\end{frame}

\begin{frame}{Parser als Arrows}
  \begin{itemize}
  \item Eigenschaften von Parsern:
    \begin{itemize}
    \item Fehlschlagen / Alternativen ($\Rightarrow \mathbf{C}_F$)
    \item Zustand: Position im Eingabestream ($\Rightarrow \mathbf{C}_S$)
    \end{itemize}
  \item Kombination: $\mathbf{C}_P = \mathbf{C}_{FFS}$
    \begin{itemize}
    \item ``innerer Fail'' möglich
      \pfeil bessere Fehlermeldungen
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Parser als Arrows (2)}
  \begin{itemize}
  \item Signaturen eines Parsers
    \begin{itemize}
    \item Parser-Kategorie: $\emptyset \ato \mathrm{A}$
    \item ``Wirklichkeit'': $[\mathrm{token}] \ato (\mathrm{A} \times
      [\mathrm{token}] + \mathrm{String}) + \mathrm{String}$
    \item nach Umwandlung in Compiler: $[\mathrm{token}] \ato \mathrm{A}$
    \end{itemize}  
  \item Token-Typ Variabel: $\mathrm{Char}$ und $\mathrm{Sexp}$
    verwendet
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Parser-Bibliothek}
  \begin{itemize}
  \item Kombinatoren: \verb+empty, eq, member, many, optional etc.+
  \item Aufruf innerer Parser: \verb+applyParser+
    \pfeil Makros:
\begin{verbatim}
  macro "addresses" (many (macro "person" 
                                 compSymbol 
                                 compSymbol))
\end{verbatim}
  \end{itemize}
\end{frame}

\section{Komponenten}
\subsection{Komponenten}

\begin{frame}{Komponenten von MagicL}
  \begin{itemize}
  \item Modelle
    \begin{itemize}
    \item Sexp
    \item Code
    \end{itemize}
  \item Eigene DSLs
    \begin{itemize}
    \item \sexp{}-Haskell
    \item \sexp{}-Compiler
    \end{itemize}
  \item Außerdem
    \begin{itemize}
    \item minimales Test-Framework
    \item Build-Tool
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Parser: $\mathrm{String} \ato \mathrm{Sexp}$}
\begin{verbatim}
data Sexp = Symbol String
          | Node   [Sexp]

whitespace = skip (many (member " \t\n"))

parseSymbol = many1 (notMember " \t\n()") >>>
              symbol

parseNode = skip (eq '(') >>> 
            (many parseSexp >>> node) >>> 
            skip (eq')')

parseSexp = whitespace >>> 
            (parseSymbol <+> parseNode) >>> 
            whitespace
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{Quellcode-Modell}
  \begin{itemize}
  \item Ansatz von Philip Wadler
  \item Beschreibung durch Haskell-Funktionen
    \begin{itemize}
    \item Elementar: \verb+text, newline, indent, append, group+
    \item Abgeleitet: \verb+lines, paragraphs, parens etc.+
    \end{itemize}
  \end{itemize}
  \begin{block}{Beispiel: Pretty-Printer für \sexps{}}
\begin{verbatim}
layoutSexp :: Sexp -> Code
layoutSexp (Symbol sym) = text sym
layoutSexp (Node children) = 
    format (map layoutSexp children)
  where format = parens . group . indent2 . lines
\end{verbatim}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Sexp-Haskell}
  \begin{itemize}
  \item Ziel: \sexp{}-basierte Erzeugung von Haskell-Code
  \item Ansatz: Haskell-Variante in \sexp{}-Syntax
  \end{itemize}
  \begin{columns}
    \begin{column}{5cm}
      \begin{block}{Sexp-Haskell}
\begin{verbatim}
(= (sumOfSquares x y)
   (+ x2 y2)
 (where                   
  (= x2 (* x x))
  (= y2 (* y y))))
\end{verbatim}
      \end{block}
    \end{column}
    \begin{column}{6cm}
      \begin{block}{Haskell}
\begin{verbatim}
sumOfSquares x y = (x2 + y2)
  where
    x2 = (x * x)         
    y2 = (y * y)
\end{verbatim}
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Implementation von Sexp-Haskell}
  \begin{itemize}
  \item Zeigt Einbindung typisierter Modelle
  \item Drei Komponenten
    \begin{itemize}
    \item Haskell-Modell
    \item Parser $\mathrm{Sexp} \ato \mathrm{Haskell}$
    \item Funktionaler Compiler $\mathrm{Haskell} \ato \mathrm{Code}$
    \end{itemize}
  \item Nutzt automatisches Finden von Compilern
  \pfeil Formulierung etwas umständlich
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Haskell-Modell}
\begin{verbatim}
...

data Pattern = ListPattern [Pattern]
             | TuplePattern [Pattern]
             | ConsPattern [Pattern]
             | StringPattern String
             | CallPattern Call                          

...
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{$\mathrm{Sexp} \ato \mathrm{Haskell}$}
\begin{verbatim}
...

instance Compilable (SexpParser Pattern) [Sexp] Pattern 
 where
  comp =
    (liftA1 ListPattern (macro "List" comp)   <+>
     liftA1 TuplePattern (macro "Tuple" comp) <+>
     liftA1 ConsPattern (macro "Cons" comp)    <+>
     liftA1 StringPattern (macro "Str" (many comp >>^ 
                                        unwords)) <+>
     liftA1 CallPattern comp)

...
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{$\mathrm{Haskell} \ato \mathrm{Code}$}
\begin{verbatim}
...

instance Compilable (Pattern -> Code) Pattern Code where
  comp (ListPattern pats)  = list $ map comp pats
  comp (TuplePattern pats) = tuple $ map comp pats
  comp (ConsPattern pats)  = parenFoldOp ":" (map comp
                                                  pats)
  comp (StringPattern str) = string str
  comp (CallPattern call)  = comp call
...

\end{verbatim}
\end{frame}

\begin{frame}[fragile]{Sexp-Compiler}
  \begin{itemize}
  \item DSL für untypisierte \sexp{}-Verarbeitung ähnlich Lisp
    \begin{itemize}
    \item Quasiquote-Operator für \sexp{}-Templates
    \item Makro-Typ: $\mathrm{[Sexp]} \ato \mathrm{[Sexp]}$
    \item Lisp-Kontrollfluss: Auto-Makros
    \end{itemize}
  \item Metarekursiv implementiert
  \end{itemize}
  \begin{block}{Beispiel: Mehrere Rückgaben}
\begin{verbatim}
(autoMac compDefArith defArithFuns
  (' (= (add x y) (+ x y))
     (= (sub x y) (- x y))))
\end{verbatim}
  \end{block}
\end{frame}

\section{Schluss}
\subsection{Schluss}

\begin{frame}{Zusammenfassung}
  \begin{itemize}
  \item Prototyp eines universellen Compiler-Frameworks
  \item Sauber fundiert: Haskell, Kategorientheorie
  \item Lisp-inspiriert: \sexps{}, Makros
  \item Allgemeiner
    \begin{itemize}
    \item Modelltypen
    \item Verarbeitungsprozesse
    \item Kontrollfluss
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Ausblick}
  \begin{itemize}
  \item Compiler-Definitionen sind etwas redundant
    \pfeil Plan: DSL für Modelldefinitionen
  \item Code-Modell in \sexps{}
  \item Unterstützung verschiedener Zielsprachen
  \item \sexp{}-basierte Softwareentwicklung
    \begin{itemize}
    \item Datenbank
    \item Strukturelle IDE
    \item Anpassbare Visualisierung
    \pfeil Model-View-Trennung von Code
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{center}
    \Huge Vielen Dank für ihre Aufmerksamkeit!
  \end{center}
\end{frame}

\end{document}
