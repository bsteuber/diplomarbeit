\documentclass[a4paper, bibgerm]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{ngerman}
\usepackage{bibgerm}
\usepackage{color}
\usepackage{graphicx}
\usepackage{pstricks}
\usepackage{pst-node}
\usepackage{hyperref}

\newcommand{\defaultscale}{0.5}

\newcommand\code[1]{\texttt{#1}}

\begin{document}

\title{MagicL: Ein Arrow-basiertes Compilerbau-Framework}
\author{Benjamin Teuber}
\date{\today}

% \maketitle

\begin{abstract}
  MagicL ist der Prototyp eines universellen Frameworks für den Entwurf
  von Programmier- und Auszeichnungssprachen. Es soll dem
  Meta-Programmierer praktische Werkzeuge für das Parsing und Übersetzen
  neuer sowie für Generation von Code bestehender Sprachen an die Hand
  geben, wobei insbesondere (jedoch nicht ausschließlich) aus
  S-Expressions aufgebaute Sprachen unterstützt werden. Die Parser- und
  Compilererstellung erfolgt nach einem kategorientheoretisch
  motivierten Baukastenansatz, so dass beispielsweise Parser durch die
  Kombination von Arrows erzeugt werden.
\end{abstract}

% \tableofcontents

\section{Einleitung}
\label{sec:intro}

Modellgetriebene Softwareentwicklung ist in aller Munde: Während UML
bald sein 20-Jähriges Jubiläum \footnote{Zumindest was die ersten
  Entwürfe angeht - der Standardisierungsprozess war erst 1997
  abgeschlossen.} feiert, verspricht Microsoft mit \textit{Oslo}
\cite{TODO} einen ``Mainstream-Ansatz für Modellierung''. IBM vermarktet
seit Jahren \textit{Rational Application Developer}, das wie auch das
freie \textit{Eclipse Modelling Framework} oder auch \textit{Enterprise
  Architect} Eclipse um modellbasierte Codegenerierung bereichern.
Code-Generation fällt auch im World Wide Web eine immer größer werdende
Rolle zu: Ob \textit{Ruby on Rails} oder \textit{Google Web Toolkit},
praktisch alle Web Frameworks generieren zumindest ihre HTML-Dateien oder
SQL-Strings für den Datenbankzugriff.

Der ganze Bereich um Code-Generation ist also ein aktuelles Thema.

\subsection{Codegenerierung}
\label{sec:intro:codegen}

Allgemein ist jedermann klar, was Codegenerierung bedeutet:
Das automatisiertes Erzeugen von Quelltext. Dennoch gibt es diverse
Unterschiede zwischen Codegenerierungswerkzeugen.

So differenziert man zwischen aktiver und passiver
Codegenerierung. Aktiv bedeutet, dass die Generierung wiederholt
ausgeführt werden kann, wenn sich etwas am Modell oder Generator ändert,
da die komplette Datei generiert wird. Passiv generierter Code dagegen
wird anschließend vom Programmierer modifiziert bzw. erst mit sinnvollen
Inhalten bestückt, so dass dieser nur normalerweise nur einmalig
generiert werden kann, wenn die Anpassungen nicht überschrieben werden
sollen. Zwischen aktiver und passiver Generierung liegen Dateien, in
denen nur markierte Abschnitte generiert werden - so dass der Rest
unverändert bleiben kann. Optimal wäre natürlich ein allgemeiner
Merge-Mechanismus, der die Arbeit des Programmierers reibungslos in die
neue Version übernimmt - dies ist aber leider schwierig zu
implementieren.

Zudem lässt sich nach Ein- und Ausgabe des Generators unterscheiden.

Vorteile:
\begin{itemize}
\item Abstraktion - Modellarchitekten beötigen keine
  Programmiersprachkenntnisse, Backend austauschbar
``Ist die Sprache an die Problemdomäne angepasst, muss man das Problem
nicht in die Sprache zwängen''
\item Produktivität - DRY-Prinzip spart u.U. viel Zeit
\item Qualität - ist der Generator fehlerfrei, gibt es keine Probleme
  bei neuen Modellen
\item Konsistenz - einheitliche Strukturen/Namen, minimiert Einarbeitungszeit
\end{itemize}

Nachteile:
\begin{itemize}
\item Dokumentation / Einarbeitung
\item Fehlersuche
\item Komplexität
\item Entwicklungsaufwand
\end{itemize}

\subsection{Lisp}
\label{sec:into:lisp}

-Code-Generation und Metaprogrammierung seit fast 50 Jahren
-was können wir lernen?
--Einheitliche Syntax macht vieles leichter
--compilererweitungen durch makros

\subsubsection{Vergleich mit XML}
\label{sec:intro:lisp:xml}

-gleiche Zielsetzung - Baumstruktur
-syntax: ``</tag>'' vs. ``)''
--nur vorteilhaft f texteditor ohne parent-matching!
-XML komplexer, da Attribute
--kann auch durch unterknoten ausgedrückt werden - wird es nur aufgrund
von hässlicher syntax nicht
--nicht mehr rekursiv, komplexe attribute gehen nicht (wirklich)

diskussion: makros good or bad

\subsection{Zielsetzung}
\label{sec:intro:goal}

\section{Erster Prototyp in Ruby}
\label{sec:sexy}

\section{Arrow-basierte Implementation in Haskell}
\label{sec:magicl}

\subsection{Kategorientheoretische Grundlagen}
\label{sec:magicl:cats}

\begin{figure}
  \centering
  \includegraphics[scale=0.4]{images/funs}
  \caption{Ein simples Funktionensystem}
  \label{fig:cat:funs}
\end{figure}

Kategorie: Abstraktion von Funktionstypen und -komposition
Bild: Mathe-Kategorie

Formal: Objekte, Morphismen (oder Arrows)
Domäne, Codomäne : M -> O
für jedes Objekt ex. $id_O$
Komposition, Axiome mit id

Funktor: Abbildung zwischen Kategorien
Muss Konsistenz mit Dom und Cod sowie id und Komp. erfüllen

\end{document}
